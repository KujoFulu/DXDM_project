package main

import (
	"math/rand"
	"time"

	"gonum.org/v1/gonum/mat"
)

// InitializeEcosystem() takes:
// data from user input: numSpecies int; growthRate float64 – for grass, the only prey in the ecosystem; deathRate []float64 – for all other species.
// It initializes the ecosystem object with a certain number of species, and returns an Ecosystem object.
// interaction matrix and deathGrowth matrix are generated by two help functions.
func InitializeEcosystem(numSpecies int, interaction mat.Matrix, deathGrowth mat.Matrix) *Ecosystem {
	// // Method 1 - some nil pointers problems
	// // initialize an Ecosystem object and a species slice
	// ecosystem := &Ecosystem{}
	// species := make([]*Specie, numSpecies)

	// // assign attributes values
	// ecosystem.interaction = interaction // InitializeInteractionMatrix(species)
	// ecosystem.deathGrowth = deathGrowth // IniRateMatrix(species)
	// ecosystem.species = species

	// // range through species slice in ecosystem, adding attributes to each specie
	// // default set ecosystem.species[0] as grass – prey; all other species are predator
	// for i := 0; i < numSpecies; i++ {
	// 	ecosystem.species[i].population = 100
	// 	ecosystem.species[i].index = i
	// }

	// Method 2 - chatGPT corrected
	// initialize an Ecosystem object and a species slice
	ecosystem := &Ecosystem{
		interaction: interaction,
		deathGrowth: deathGrowth,
		species:     make([]*Specie, numSpecies), // Allocate space for numSpecies pointers to Specie
	}

	// Initialize each specie in the species slice, setting the index and population
	for i := range ecosystem.species {
		ecosystem.species[i] = &Specie{
			population: 100, // Default population, you might want to differentiate for the first species (grass)
			index:      i,
		}
	}

	return ecosystem
}

func InitializePop(species []*Specie) mat.Matrix {
	// get the length of the species slice
	numSpecies := len(species)

	// range through the species slice, and extract them all into a slice
	pop := make([]float64, numSpecies)
	for _, specie := range species {
		pop[specie.index] = specie.population
	}

	// convert the slice into a matrix
	popMatrix := mat.NewDense(numSpecies, 1, pop)

	return popMatrix
}

// ecosystem.deathGrowth = IniRateMatrix(deathGrowth)
// IniInterMatrix() takes a slice of float64 objects, and returns a mat.Matrix object.
func IniRateMatrix(numSpecies int) mat.Matrix {
	// get the number of species
	n := numSpecies

	// randomly generate a slice of float64 numbers
	deathGrowth := generateDeathGrowthSlice(n)

	// convert the slice into a n*1 death and growth matrix
	rateMatrix := mat.NewDense(n, 1, deathGrowth)

	return rateMatrix
}

// generateDeathGrowthSlice generates a slice of float64 numbers with the first number in the range (0, 1)
// and the others in the range (-1, 0)
func generateDeathGrowthSlice(n int) []float64 {
	deathGrowth := make([]float64, n)
	// Seed the random number generator
	rand.Seed(time.Now().UnixNano())

	// Set the first element to a random number in (0, 1)
	deathGrowth[0] = rand.Float64()

	// Set the remaining elements to random numbers in (-1, 0)
	for i := 1; i < n; i++ {
		deathGrowth[i] = rand.Float64() - 1.0 // This generates a number in [0, 1) and then subtracts 1 to shift to [-1, 0)
	}

	return deathGrowth
}

// InitializeInteractionMatrix() takes a species slice, and returns an interaction matrix.
// The interaction matrix is a square matrix with the size of the number of species.
// The diagonal elements are all 0, and the off-diagonal elements are randomly generated.
// The off-diagonal elements are the interaction coefficients between species.
// The interaction coefficients are randomly generated between -1 and 1.
func InitializeInteractionMatrix(numSpecies int) mat.Matrix {
	// initialize a slice to store the interaction coefficients
	interaction := make([]float64, numSpecies*numSpecies)

	// range through the species slice, and assign random interaction coefficients to each specie. Make sure species[i][j] should be the same as species[j][i].
	for i := 0; i < numSpecies; i++ {
		for j := 0; j < numSpecies; j++ {
			if i == j {
				interaction[i*numSpecies+j] = 0
			} else {
				interaction[i*numSpecies+j] = rand.Float64()*2 - 1
				interaction[j*numSpecies+i] = interaction[i*numSpecies+j]
			}
		}
	}

	// convert the slice into a matrix
	interactionMatrix := mat.NewDense(numSpecies, numSpecies, interaction)

	return interactionMatrix
}
